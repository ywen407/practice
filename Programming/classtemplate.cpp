/*클래스 템플릿*/
//함수 템플릿처럼 똑같이 쓴다.
//다만 주의할점은 템플릿 클래스를 상속할때는 구체화를 시킨후에 상속해야한다.
//또한 템플릿 클래스는 객체가 생성될때 구체화가 되지만..상속되는 경우는 컴파일러가 객체 생성 유무 상관없어 구체화한다
//->일반적으로 객체생성할떄 구체화함. 상속할떄는 구체화를 시킨걸 상속함.
//또한 템플릿을 구현할떄는 컴파일 시점에 구체화가 되어야 하므로, 헤더파일에 모든 정의가 있어야한다.->모듈화 할때 정의부와 선언부가 분리되어 있으므로
//링크가 되어야지 구체화가 이루지는데 템플릿은 컴파일 타임에 구체화가 되므로 모듈화시 헤더파일에 정의부를 정의해야한다.
//아마 선언부랑 정의부랑 같이 있으면 상관없을듯 하다.아마도 모듈화시에..
//템플릿이 아닌 함수들은 링크시 바인딩 되므로 컴파일 타임에 함수의 원형만 있으면 문제가 없다.



#include <iostream>

using namespace std;

template <typename T>
class A
{
    public:
        A(T s):a{s}{cout<<"a값으로 객체가 생성되었습니다"<<endl;};
        void foo(T x)
        {
            a=x;
            cout <<a<<"로 입력되었습니다"<<endl;
        }
    private:
        T a;

};

class B :public A<int>
{
    public:
        B(int x):A{x}{};

        void func()
        {
            cout<<"func"<<endl;
        }
    
};
int main()
{
    B* b=new B(3);
    b->foo(4);
    return 0;
}

